# Cursor Rules for AI Assistant

## 0. Implementation Principles

You must read this file in its entirety before responding to me in agent mode.

At the start of each response you give me in agent mode, reply first with 
"I read your cursorRules file big dog"

# Cursor Development Rules & AI Collaboration Guide
 
## üìú Core Philosophy
 
1.  **Simplicity:** Prioritize simple, clear, and maintainable solutions. Avoid unnecessary complexity or over-engineering. As soon as LoC exceeds 300 for a file, we should be breaking that file out into a separate component/file.
2.  **Iterate:** Prefer iterating on existing, working code rather than building entirely new solutions from scratch, unless fundamentally necessary or explicitly requested. You should never assume. Ever. Always grep aggressively for what you need to ensure you are iterating instead of building from scratch. We only build from scratch when necessary and you must prompt me with "Hey big dog, do you sign-off on building a new X here instead of iterating?"
3.  **Focus:** Concentrate efforts on the specific task assigned. Avoid unrelated changes or scope creep. 
4.  **Quality:** Strive for a clean, organized, well-tested, and secure codebase.
5.  **Thoroughness:** Don't just look at the file I send you. If the file is a module with a parent component, look at the parent component to ensure you understand the full context of the code. Similarly, if it has a child component look at that to ensure you understand the impacts of your suggested changes. You really need to ensure that you have a full understanding of the entire chain of context when you make a suggestion/change. Grok this each time by saying "In an effort to be thorough, I traced X function from parent component Y" or "I traced X function to child component Z and ensured changes were propagated"

## ü§ñ AI Collaboration & Prompting
 
1.  **Clarity is Key:** Provide clear, specific, and unambiguous instructions to the AI. Define the desired outcome, constraints, and context.
2.  **Context Referencing:** If a task spans multiple interactions, explicitly remind the AI of relevant previous context, decisions, or code snippets.
3.  **Suggest vs. Apply:** Clearly state whether the AI should *suggest* a change for human review or *apply* a change directly (use only when high confidence and task is well-defined). Use prefixes like "Suggestion:" or "Applying fix:".
4.  **Question AI Output:** Human developers should critically review AI-generated code. Question assumptions, verify logic, and don't blindly trust confident-sounding but potentially incorrect suggestions (hallucinations).
5.  **Focus the AI:** Guide the AI to work on specific, focused parts of the task. Avoid overly broad requests that might lead to architectural or logical errors.
6.  **Leverage Strengths:** Use the AI for tasks it excels at (boilerplate generation, refactoring specific patterns, finding syntax errors, generating test cases) but maintain human oversight for complex logic, architecture, and security.
7.  **Incremental Interaction:** Break down complex tasks into smaller steps for the AI. Review and confirm each step before proceeding.
8.  **Standard Check-in (for AI on large tasks):** Before providing significant code suggestions:
    *   "Confirming understanding: I've reviewed [specific document/previous context]. The goal is [task goal], adhering to [key pattern/constraint]. Proceeding with [planned step]." (This replaces the more robotic "STOP AND VERIFY").
9.  **No Auto-Dev Server:** Never automatically run `npm run dev` or development servers after implementations. Make changes, then check in with the human developer for review. The AI cannot effectively interact with running applications and this wastes time.
 
## ‚ú® Code Quality & Style
 
1.  **TypeScript Guidelines:** Use strict typing (avoid `any`). Document complex logic or public APIs.
2.  **Readability & Maintainability:** Write clean, well-organized code.
3.  **Small Files & Components:**
    *   Keep files under **300 lines**. Refactor proactively.
    *   Break down large React components into smaller, single-responsibility components.
4.  **Avoid Duplication (DRY):** Actively look for and reuse existing functionality. Refactor to eliminate duplication.
5.  **Linting/Formatting:** Ensure all code conforms to project's ESLint/Prettier rules.
6.  **Pattern Consistency:** Adhere to established project patterns. Don't introduce new ones without discussion/explicit instruction. If replacing an old pattern, ensure the old implementation is fully removed.
7.  **File Naming:** Use clear, descriptive names. Avoid "temp", "refactored", "improved", etc., in permanent file names.
8.  **No One-Time Scripts:** Do not commit one-time utility scripts into the main codebase.
 
## ‚ôªÔ∏è Refactoring
 
1.  **Purposeful Refactoring:** Refactor to improve clarity, reduce duplication, simplify complexity, or adhere to architectural goals.
2.  **Holistic Check:** When refactoring, look for duplicate code, similar components/files, and opportunities for consolidation across the affected area.
3.  **Edit, Don't Copy:** Modify existing files directly. Do not duplicate files and rename them (e.g., `component-v2.tsx`).
4.  **Verify Integrations:** After refactoring, ensure all callers, dependencies, and integration points function correctly. Run relevant tests.
 
## üìÑ Documentation Maintenance
 
1.  **Keep Rules Updated:** This `.cursorRules` file should be reviewed and updated periodically to reflect learned best practices and project evolution.